{"title":"Algorithm Problem : 多种二叉树遍历算法","date":"2019-03-05T15:07:34.000Z","slug":"Algorithm-Problem-多种二叉树遍历算法","comments":true,"updated":"2019-03-05T15:10:08.389Z","content":"<h3 id=\"二叉树按层遍历、左视图遍历、右视图遍历、俯视图遍历\">二叉树按层遍历、左视图遍历、右视图遍历、俯视图遍历<a href=\"post/Algorithm-Problem-多种二叉树遍历算法#二叉树按层遍历、左视图遍历、右视图遍历、俯视图遍历\"></a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;queue&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">enum NodeType &#123;</span><br><span class=\"line\">    NODE_TYPE_NORMAL,</span><br><span class=\"line\">    NODE_TYPE_EMPTY,</span><br><span class=\"line\">    NODE_TYPE_HEAD,</span><br><span class=\"line\">    NODE_TYPE_TAIL,</span><br><span class=\"line\">    NODE_TYPE_HEADTAIL</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct BinaryNode &#123;</span><br><span class=\"line\">    int m_value;</span><br><span class=\"line\">    BinaryNode* m_left;</span><br><span class=\"line\">    BinaryNode* m_right;</span><br><span class=\"line\">    NodeType m_type;</span><br><span class=\"line\"></span><br><span class=\"line\">    BinaryNode(int v, BinaryNode* left, BinaryNode* right, NodeType type)</span><br><span class=\"line\">            : m_value(v), m_left(left), m_right(right), m_type(type) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class BinaryTree &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    BinaryTree() : m_root(NULL) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~BinaryTree() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void insertNode(int v) &#123;</span><br><span class=\"line\">        internalInsert(m_root, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //正常遍历二叉树</span><br><span class=\"line\">    void normalTraverse() &#123;</span><br><span class=\"line\">        if (NULL == m_root) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        std::queue&lt;BinaryNode*&gt; queue;</span><br><span class=\"line\">        queue.push(m_root);</span><br><span class=\"line\">        while (!queue.empty()) &#123;</span><br><span class=\"line\">            BinaryNode* aNode = queue.front();</span><br><span class=\"line\">            std::cout &lt;&lt; aNode-&gt;m_value &lt;&lt; &quot;  &quot;;</span><br><span class=\"line\">            if (NULL != aNode-&gt;m_left) &#123;</span><br><span class=\"line\">                queue.push(aNode-&gt;m_left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (NULL != aNode-&gt;m_right) &#123;</span><br><span class=\"line\">                queue.push(aNode-&gt;m_right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            queue.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //按行遍历二叉树</span><br><span class=\"line\">    void lineTraverse() &#123;</span><br><span class=\"line\">        if (NULL == m_root) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        std::queue&lt;BinaryNode*&gt; queue;</span><br><span class=\"line\">        queue.push(m_root);</span><br><span class=\"line\">        BinaryNode emptyNode(0, NULL, NULL, NODE_TYPE_EMPTY);</span><br><span class=\"line\">        queue.push(&amp;emptyNode);</span><br><span class=\"line\">        while (!queue.empty()) &#123;</span><br><span class=\"line\">            BinaryNode* aNode = queue.front();</span><br><span class=\"line\">            if (aNode-&gt;m_type == NODE_TYPE_NORMAL) &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; aNode-&gt;m_value &lt;&lt; &quot;  &quot;;</span><br><span class=\"line\">                if (NULL != aNode-&gt;m_left) &#123;</span><br><span class=\"line\">                    queue.push(aNode-&gt;m_left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (NULL != aNode-&gt;m_right) &#123;</span><br><span class=\"line\">                    queue.push(aNode-&gt;m_right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                queue.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (aNode-&gt;m_type == NODE_TYPE_EMPTY) &#123;</span><br><span class=\"line\">                if (queue.size() == 1) &#123;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">                BinaryNode emptyNode(0, NULL, NULL, NODE_TYPE_EMPTY);</span><br><span class=\"line\">                queue.push(&amp;emptyNode);</span><br><span class=\"line\">                queue.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //遍历二叉树左视图</span><br><span class=\"line\">    void leftSideTraverse() &#123;</span><br><span class=\"line\">        if (NULL == m_root) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        std::queue&lt;BinaryNode*&gt; queue;</span><br><span class=\"line\">        queue.push(m_root);</span><br><span class=\"line\">        bool shouldPrint = true;</span><br><span class=\"line\">        BinaryNode emptyNode(0, NULL, NULL, NODE_TYPE_EMPTY);</span><br><span class=\"line\">        queue.push(&amp;emptyNode);</span><br><span class=\"line\">        while (!queue.empty()) &#123;</span><br><span class=\"line\">            BinaryNode* aNode = queue.front();</span><br><span class=\"line\">            if (aNode-&gt;m_type == NODE_TYPE_NORMAL) &#123;</span><br><span class=\"line\">                if (shouldPrint) &#123;</span><br><span class=\"line\">                    std::cout &lt;&lt; aNode-&gt;m_value &lt;&lt; &quot;  &quot;;</span><br><span class=\"line\">                    shouldPrint = false;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (NULL != aNode-&gt;m_left) &#123;</span><br><span class=\"line\">                    queue.push(aNode-&gt;m_left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (NULL != aNode-&gt;m_right) &#123;</span><br><span class=\"line\">                    queue.push(aNode-&gt;m_right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                queue.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (aNode-&gt;m_type == NODE_TYPE_EMPTY) &#123;</span><br><span class=\"line\">                if (queue.size() == 1) &#123;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                shouldPrint = true;</span><br><span class=\"line\">                std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">                BinaryNode emptyNode(0, NULL, NULL, NODE_TYPE_EMPTY);</span><br><span class=\"line\">                queue.push(&amp;emptyNode);</span><br><span class=\"line\">                queue.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //遍历二叉树右视图</span><br><span class=\"line\">    void rightSideTraverse() &#123;</span><br><span class=\"line\">        if (NULL == m_root) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        std::queue&lt;BinaryNode*&gt; queue;</span><br><span class=\"line\">        queue.push(m_root);</span><br><span class=\"line\">        BinaryNode emptyNode(0, NULL, NULL, NODE_TYPE_EMPTY);</span><br><span class=\"line\">        queue.push(&amp;emptyNode);</span><br><span class=\"line\">        int oldValue;</span><br><span class=\"line\">        while (!queue.empty()) &#123;</span><br><span class=\"line\">            BinaryNode* aNode = queue.front();</span><br><span class=\"line\">            if (aNode-&gt;m_type == NODE_TYPE_NORMAL) &#123;</span><br><span class=\"line\">                oldValue = aNode-&gt;m_value;</span><br><span class=\"line\">                if (NULL != aNode-&gt;m_left) &#123;</span><br><span class=\"line\">                    queue.push(aNode-&gt;m_left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (NULL != aNode-&gt;m_right) &#123;</span><br><span class=\"line\">                    queue.push(aNode-&gt;m_right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                queue.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (aNode-&gt;m_type == NODE_TYPE_EMPTY) &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; oldValue &lt;&lt; std::endl;</span><br><span class=\"line\">                if (queue.size() == 1) &#123;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                BinaryNode emptyNode(0, NULL, NULL, NODE_TYPE_EMPTY);</span><br><span class=\"line\">                queue.push(&amp;emptyNode);</span><br><span class=\"line\">                queue.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //遍历二叉树俯视图</span><br><span class=\"line\">    void upsidelTraverse() &#123;</span><br><span class=\"line\">        if (NULL == m_root) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        m_root-&gt;m_type = NODE_TYPE_HEADTAIL;</span><br><span class=\"line\">        std::queue&lt;BinaryNode*&gt; queue;</span><br><span class=\"line\">        queue.push(m_root);</span><br><span class=\"line\">        while (!queue.empty()) &#123;</span><br><span class=\"line\">            BinaryNode* aNode = queue.front();</span><br><span class=\"line\">            std::cout &lt;&lt; aNode-&gt;m_value &lt;&lt; std::endl;</span><br><span class=\"line\">            if (aNode-&gt;m_type == NODE_TYPE_HEADTAIL) &#123;</span><br><span class=\"line\">                if (NULL != aNode-&gt;m_left) &#123;</span><br><span class=\"line\">                    aNode-&gt;m_left-&gt;m_type = NODE_TYPE_HEAD;</span><br><span class=\"line\">                    queue.push(aNode-&gt;m_left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (NULL != aNode-&gt;m_right) &#123;</span><br><span class=\"line\">                    aNode-&gt;m_right-&gt;m_type = NODE_TYPE_TAIL;</span><br><span class=\"line\">                    queue.push(aNode-&gt;m_right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                queue.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (aNode-&gt;m_type == NODE_TYPE_HEAD) &#123;</span><br><span class=\"line\">                if (NULL != aNode-&gt;m_left) &#123;</span><br><span class=\"line\">                    aNode-&gt;m_left-&gt;m_type = NODE_TYPE_HEAD;</span><br><span class=\"line\">                    queue.push(aNode-&gt;m_left);</span><br><span class=\"line\">                    queue.pop();</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                queue.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (aNode-&gt;m_type == NODE_TYPE_TAIL) &#123;</span><br><span class=\"line\">                if (NULL != aNode-&gt;m_right) &#123;</span><br><span class=\"line\">                    aNode-&gt;m_right-&gt;m_type = NODE_TYPE_TAIL;</span><br><span class=\"line\">                    queue.push(aNode-&gt;m_right);</span><br><span class=\"line\">                    queue.pop();</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                queue.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    void internalInsert(BinaryNode*&amp; node, int v) &#123;</span><br><span class=\"line\">        if (NULL == node) &#123;</span><br><span class=\"line\">            node = new BinaryNode(v, NULL, NULL, NODE_TYPE_NORMAL);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (v == node-&gt;m_value) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125; else if (v &gt; node-&gt;m_value) &#123;</span><br><span class=\"line\">            internalInsert(node-&gt;m_right, v);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            internalInsert(node-&gt;m_left, v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    BinaryNode* m_root;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    BinaryTree tree;</span><br><span class=\"line\">    tree.insertNode(20);</span><br><span class=\"line\">    tree.insertNode(14);</span><br><span class=\"line\">    tree.insertNode(7);</span><br><span class=\"line\">    tree.insertNode(18);</span><br><span class=\"line\">    tree.insertNode(28);</span><br><span class=\"line\">    tree.insertNode(27);</span><br><span class=\"line\">    tree.insertNode(23);</span><br><span class=\"line\">    tree.insertNode(24);</span><br><span class=\"line\">    tree.normalTraverse();</span><br><span class=\"line\">    tree.lineTraverse();</span><br><span class=\"line\">    tree.leftSideTraverse();</span><br><span class=\"line\">    tree.rightSideTraverse();</span><br><span class=\"line\">    tree.upsidelTraverse();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","next":{"title":"Algorithm Problem : 区间树详解","slug":"Algorithm-Problem-区间树详解"},"link":"http://yoursite.com/post/Algorithm-Problem-多种二叉树遍历算法/"}