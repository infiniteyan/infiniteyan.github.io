{"title":"多线程编程-条件变量","date":"2020-03-25T12:45:28.000Z","slug":"多线程编程-条件变量","comments":true,"updated":"2020-03-25T12:49:44.419Z","content":"<p>互斥锁std::mutex是一种最常见的线程间同步的手段，但是在有些情况下不太高效。</p>\n<p>假设想实现一个简单的消费者生产者模型，一个线程往队列中放入数据，一个线程往队列中取数据，取数据前需要判断一下队列中确实有数据，由于这个队列是线程间共享的，所以，需要使用互斥锁进行保护，一个线程在往队列添加数据的时候，另一个线程不能取，反之亦然。用互斥锁实现如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;deque&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">deque</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex mu;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function_1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::unique_lock&lt;<span class=\"built_in\">std</span>::mutex&gt; locker(mu);</span><br><span class=\"line\">        q.push_front(count);</span><br><span class=\"line\">        locker.unlock();</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::this_thread::sleep_for(<span class=\"built_in\">std</span>::chrono::seconds(<span class=\"number\">1</span>));</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function_2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( data != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::unique_lock&lt;<span class=\"built_in\">std</span>::mutex&gt; locker(mu);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!q.empty()) &#123;</span><br><span class=\"line\">            data = q.back();</span><br><span class=\"line\">            q.pop_back();</span><br><span class=\"line\">            locker.unlock();</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"t2 got a value from t1: \"</span> &lt;&lt; data &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            locker.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(function_1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t2</span><span class=\"params\">(function_2)</span></span>;</span><br><span class=\"line\">    t1.join();</span><br><span class=\"line\">    t2.join();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出结果</span></span><br><span class=\"line\"><span class=\"comment\">//t2 got a value from t1: 10</span></span><br><span class=\"line\"><span class=\"comment\">//t2 got a value from t1: 9</span></span><br><span class=\"line\"><span class=\"comment\">//t2 got a value from t1: 8</span></span><br><span class=\"line\"><span class=\"comment\">//t2 got a value from t1: 7</span></span><br><span class=\"line\"><span class=\"comment\">//t2 got a value from t1: 6</span></span><br><span class=\"line\"><span class=\"comment\">//t2 got a value from t1: 5</span></span><br><span class=\"line\"><span class=\"comment\">//t2 got a value from t1: 4</span></span><br><span class=\"line\"><span class=\"comment\">//t2 got a value from t1: 3</span></span><br><span class=\"line\"><span class=\"comment\">//t2 got a value from t1: 2</span></span><br><span class=\"line\"><span class=\"comment\">//t2 got a value from t1: 1</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，互斥锁其实可以完成这个任务，但是却存在着性能问题。</p>\n<p>首先，function_1函数是生产者，在生产过程中，std::this_thread::sleep_for(std::chrono::seconds(1));表示延时1s，所以这个生产的过程是很慢的；function_2函数是消费者，存在着一个while循环，只有在接收到表示结束的数据的时候，才会停止，每次循环内部，都是先加锁，判断队列不空，然后就取出一个数，最后解锁。所以说，在1s内，做了很多无用功！这样的话，CPU占用率会很高，可能达到100%（单核）。<br>解决办法之一是给消费者也加一个小延时，如果一次判断后，发现队列是空的，就惩罚一下自己，延时500ms，这样可以减小CPU的占用率。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function_2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( data != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::unique_lock&lt;<span class=\"built_in\">std</span>::mutex&gt; locker(mu);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!q.empty()) &#123;</span><br><span class=\"line\">            data = q.back();</span><br><span class=\"line\">            q.pop_back();</span><br><span class=\"line\">            locker.unlock();</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"t2 got a value from t1: \"</span> &lt;&lt; data &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            locker.unlock();</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::this_thread::sleep_for(<span class=\"built_in\">std</span>::chrono::milliseconds(<span class=\"number\">500</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后困难之处在于，如何确定这个延时时间呢，假如生产者生产的很快，消费者却延时500ms，也不是很好，如果生产者生产的更慢，那么消费者延时500ms，还是不必要的占用了CPU。<br>这就引出了条件变量（condition variable）,c++11中提供了#include &lt;condition_variable&gt;头文件，其中的std::condition_variable可以和std::mutex结合一起使用，其中有两个重要的接口，notify_one()和wait()，wait()可以让线程陷入休眠状态，在消费者生产者模型中，如果生产者发现队列中没有东西，就可以让自己休眠，但是不能一直不干活啊，notify_one()就是唤醒处于wait中的其中一个条件变量（可能当时有很多条件变量都处于wait状态）。那什么时刻使用notify_one()比较好呢，当然是在生产者往队列中放数据的时候了，队列中有数据，就可以赶紧叫醒等待中的线程起来干活了。</p>\n<p>使用条件变量修改后如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;deque&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">deque</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex mu;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::condition_variable cond;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function_1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::unique_lock&lt;<span class=\"built_in\">std</span>::mutex&gt; locker(mu);</span><br><span class=\"line\">        q.push_front(count);</span><br><span class=\"line\">        locker.unlock();</span><br><span class=\"line\">        cond.notify_one();  <span class=\"comment\">// Notify one waiting thread, if there is one.</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::this_thread::sleep_for(<span class=\"built_in\">std</span>::chrono::seconds(<span class=\"number\">1</span>));</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function_2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( data != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::unique_lock&lt;<span class=\"built_in\">std</span>::mutex&gt; locker(mu);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(q.empty())</span><br><span class=\"line\">            cond.wait(locker); <span class=\"comment\">// Unlock mu and wait to be notified</span></span><br><span class=\"line\">        data = q.back();</span><br><span class=\"line\">        q.pop_back();</span><br><span class=\"line\">        locker.unlock();</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"t2 got a value from t1: \"</span> &lt;&lt; data &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(function_1)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t2</span><span class=\"params\">(function_2)</span></span>;</span><br><span class=\"line\">    t1.join();</span><br><span class=\"line\">    t2.join();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时CPU的占用率也很低。</p>\n<p>上面的代码有三个注意事项：</p>\n<ul>\n<li>在function_2中，在判断队列是否为空的时候，使用的是while(q.empty())，而不是if(q.empty())，这是因为wait()从阻塞到返回，不一定就是由于notify_one()函数造成的，还有可能由于系统的不确定原因唤醒（可能和条件变量的实现机制有关），这个的时机和频率都是不确定的，被称作伪唤醒，如果在错误的时候被唤醒了，执行后面的语句就会错误，所以需要再次判断队列是否为空，如果还是为空，就继续wait()阻塞。</li>\n<li>在管理互斥锁的时候，使用的是std::unique_lock而不是std::lock_guard，而且事实上也不能使用std::lock_guard，这需要先解释下wait()函数所做的事情。可以看到，在wait()函数之前，使用互斥锁保护了，如果wait的时候什么都没做，岂不是一直持有互斥锁？那生产者也会一直卡住，不能够将数据放入队列中了。所以，wait()函数会先调用互斥锁的unlock()函数，然后再将自己睡眠，在被唤醒后，又会继续持有锁，保护后面的队列操作。而lock_guard没有lock和unlock接口，而unique_lock提供了。这就是必须使用unique_lock的原因。</li>\n<li>使用细粒度锁，尽量减小锁的范围，在notify_one()的时候，不需要处于互斥锁的保护范围内，所以在唤醒条件变量之前可以将锁unlock()。</li>\n</ul>\n<p>还可以将cond.wait(locker);换一种写法，wait()的第二个参数可以传入一个函数表示检查条件，这里使用lambda函数最为简单，如果这个函数返回的是true，wait()函数不会阻塞会直接返回，如果这个函数返回的是false，wait()函数就会阻塞着等待唤醒，如果被伪唤醒，会继续判断函数返回值。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function_2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( data != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::unique_lock&lt;<span class=\"built_in\">std</span>::mutex&gt; locker(mu);</span><br><span class=\"line\">        cond.wait(locker, []()&#123; <span class=\"keyword\">return</span> !q.empty();&#125; );  <span class=\"comment\">// Unlock mu and wait to be notified</span></span><br><span class=\"line\">        data = q.back();</span><br><span class=\"line\">        q.pop_back();</span><br><span class=\"line\">        locker.unlock();</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"t2 got a value from t1: \"</span> &lt;&lt; data &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了notify_one()函数，c++还提供了notify_all()函数，可以同时唤醒所有处于wait状态的条件变量。</p>\n","next":{"title":"智能指针之weak_ptr","slug":"智能指针之weak-ptr"},"link":"http://yoursite.com/post/多线程编程-条件变量/"}