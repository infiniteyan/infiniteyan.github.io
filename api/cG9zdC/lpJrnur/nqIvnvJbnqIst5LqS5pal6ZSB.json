{"title":"多线程编程-互斥锁","date":"2020-03-25T13:43:43.000Z","slug":"多线程编程-互斥锁","comments":true,"updated":"2020-03-25T13:53:50.981Z","content":"<p>C++11中提供了std::mutex互斥量，共包含四种类型：</p>\n<ul>\n<li>std::mutex：最基本的mutex类。</li>\n<li>std::recursive_mutex：递归mutex类，能多次锁定而不死锁。</li>\n<li>std::time_mutex：定时mutex类，可以锁定一定的时间。</li>\n<li>std::recursive_timed_mutex：定时递归mutex类。<br>另外，还提供了两种锁类型：</li>\n<li>std::lock_guard：方便线程对互斥量上锁。</li>\n<li>std::unique_lock：方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li>\n</ul>\n<p>以及相关的函数：<br>std::try_lock：尝试同时对多个互斥量上锁。<br>std::lock：可以同时对多个互斥量上锁。</p>\n<h3 id=\"std-mutex\">std::mutex<a href=\"post/多线程编程-互斥锁#std-mutex\"></a></h3><p>std::mutex是C++中最基本的互斥量，提供了独占所有权的特性，std::mutex提供了以下成员函数<br>构造函数：std::mutex不允许拷贝构造，也不允许move拷贝，最初产生的mutex对象是处于unlocked状态的。<br>lock()：调用线程将锁住该互斥量，线程调用该函数会发生以下3种情况：<br>（1）如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用unlock之前，该线程一直拥有该锁。<br>（2）如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。<br>（3）如果当前互斥量被当前调用线程锁住，则会产生死锁,，也就是说同一个线程中不允许锁两次。<br>unlock()：解锁，释放对互斥量的所有权。<br>try_lock()：尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞，线程调用该函数会出现下面3种情况：<br>（1）如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用unlock释放互斥量。<br>（2）如果当前互斥量被其他线程锁住，则当前调用线程返回false，而并不会被阻塞掉。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex mtx;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        mtx.lock();</span><br><span class=\"line\">        ++counter;</span><br><span class=\"line\">        mtx.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::thread threads[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        threads[i] = <span class=\"built_in\">std</span>::thread(func);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; th : threads)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        th.join();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; counter &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;   <span class=\"comment\">// 100000</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码实现了对counter的同步操作，同时只有一个线程能对counter操作。我们再看一下try_lock的结果：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mtx.try_lock())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ++counter;</span><br><span class=\"line\">            mtx.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::thread threads[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        threads[i] = <span class=\"built_in\">std</span>::thread(func);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; th : threads)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        th.join();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; counter &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;   <span class=\"comment\">// 不固定</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，使用try_lock对counter进行控制，最终结果是不固定的。因为try_lock在其他线程占有互斥量的情况下会返回false但是不阻塞，所以会跳过一部分的++counter操作。</p>\n<h3 id=\"std-recursive-mutex\">std::recursive_mutex<a href=\"post/多线程编程-互斥锁#std-recursive-mutex\"></a></h3><p>std::recursive_mutex与std::mutex类似，但是它能够进行多次lock，这样能够规避一些死锁问题：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::recursive_mutex mtx;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mtx.lock();</span><br><span class=\"line\">    counter++;</span><br><span class=\"line\">    mtx.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mtx.lock();</span><br><span class=\"line\">    func2();</span><br><span class=\"line\">    counter++;</span><br><span class=\"line\">    mtx.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(func1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    t.join();</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; counter &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;   <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上面的代码所示，有时候会在两个函数中分别对数据进行lock，如果在一个函数中又调用了另一个函数，此时如果使用std::mutex将会死锁，而用std::recursive_mutex则不会。看起来std::recursive_mutex很不错，但是使用的时候也需要多注意，lock和unlock的数量必须相等，否则会出错。<br>另外还有性能的问题，std::recursive_mutex的性能会比较差一些，从下面的例子中可以看出来，性能上要差了1倍左右。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::recursive_mutex rmtx;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex mtx;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> begin = <span class=\"built_in\">std</span>::chrono::system_clock::now();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        mtx.lock();</span><br><span class=\"line\">        counter++;</span><br><span class=\"line\">        mtx.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> end = <span class=\"built_in\">std</span>::chrono::system_clock::now();</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; (end - begin).count() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;  <span class=\"comment\">// 330</span></span><br><span class=\"line\"></span><br><span class=\"line\">    begin = <span class=\"built_in\">std</span>::chrono::system_clock::now();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rmtx.lock();</span><br><span class=\"line\">        counter++;</span><br><span class=\"line\">        rmtx.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    end = <span class=\"built_in\">std</span>::chrono::system_clock::now();         </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; (end - begin).count() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">// 597</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"std-time-mutex和std-recursive-timed-mutex\">std::time_mutex和std::recursive_timed_mutex<a href=\"post/多线程编程-互斥锁#std-time-mutex和std-recursive-timed-mutex\"></a></h3><p>这两种互斥量类型和不带time的相比，多了两个成员函数：</p>\n<ul>\n<li>try_lock_for()：函数参数表示一个时间范围，在这一段时间范围之内线程如果没有获得锁则保持阻塞；如果在此期间其他线程释放了锁，则该线程可获得该互斥锁；如果超时(指定时间范围内没有获得锁)，则函数调用返回false。</li>\n<li>try_lock_until()：函数参数表示一个时刻，在这一时刻之前线程如果没有获得锁则保持阻塞；如果在此时刻前其他线程释放了锁，则该线程可获得该互斥锁；如果超过指定时刻没有获得锁，则函数调用返回false。<br>首先来看看try_lock_for的用法，下面的例子可以看出，try_lock_for等待指定时间后没有获取到锁，会返回false。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;       // std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;         // std::chrono::milliseconds</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;         // std::thread</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;          // std::timed_mutex</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::timed_mutex mtx;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fireworks</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为这个锁等待200ms</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!mtx.try_lock_for(<span class=\"built_in\">std</span>::chrono::milliseconds(<span class=\"number\">200</span>))) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> out = <span class=\"built_in\">std</span>::to_string(n);</span><br><span class=\"line\">        out += <span class=\"string\">\"wait\\n\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取锁后等待700ms再解锁</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::this_thread::sleep_for(<span class=\"built_in\">std</span>::chrono::milliseconds(<span class=\"number\">700</span>));</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"end\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    mtx.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::thread threads[<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       threads[i] = <span class=\"built_in\">std</span>::thread(fireworks, i);</span><br><span class=\"line\">       <span class=\"comment\">// 为了保证线程按照顺序开始，保证输出一致</span></span><br><span class=\"line\">       <span class=\"built_in\">std</span>::this_thread::sleep_for(<span class=\"built_in\">std</span>::chrono::milliseconds(<span class=\"number\">10</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; th : threads)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       th.join();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果</span></span><br><span class=\"line\"><span class=\"number\">1</span>wait</span><br><span class=\"line\"><span class=\"number\">2</span>wait</span><br><span class=\"line\"><span class=\"number\">1</span>wait</span><br><span class=\"line\"><span class=\"number\">2</span>wait</span><br><span class=\"line\"><span class=\"number\">1</span>wait</span><br><span class=\"line\"><span class=\"number\">2</span>wait</span><br><span class=\"line\">end</span><br><span class=\"line\"><span class=\"number\">2</span>wait</span><br><span class=\"line\"><span class=\"number\">2</span>wait</span><br><span class=\"line\"><span class=\"number\">2</span>wait</span><br><span class=\"line\">end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>std::recursive_timed_mutex和std::recursive_mutex的区别也是一样的，多了两个成员函数。</p>\n<h3 id=\"std-lock-guard和std-unique-lock\">std::lock_guard和std::unique_lock<a href=\"post/多线程编程-互斥锁#std-lock-guard和std-unique-lock\"></a></h3><p>std::lock_guard是一个模板类，模板类型可以是以上的四种锁，用于自动锁定解锁，直到对象作用域结束。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::mutex mtx;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::lock_guard&lt;<span class=\"built_in\">std</span>::mutex&gt; guard(mtx);</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; mtx.try_lock() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;  <span class=\"comment\">// 0，互斥量被占用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; mtx.try_lock() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;     <span class=\"comment\">// 0，互斥量释放 </span></span><br><span class=\"line\">    mtx.unlock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>std::unique_lock也支持std::lock_guard的功能，但是区别在于它提供跟多的成员函数使用更加灵活，并且能够和condition_variable一起使用来控制线程同步，内容较多以后有机会在做介绍，有兴趣的朋友可以自己了解。</p>\n<h3 id=\"std-try-lock、std-lock、std-call-once\">std::try_lock、std::lock、std::call_once<a href=\"post/多线程编程-互斥锁#std-try-lock、std-lock、std-call-once\"></a></h3><p>std::try_lock支持尝试对多个互斥量进行锁定，尝试锁定成功返回-1，否则返回锁定失败的互斥量的位置，例如第一个锁定失败返回0、第二个失败返回1。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::mutex mtx1;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::mutex mtx2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">-1</span> == <span class=\"built_in\">std</span>::try_lock(mtx1, mtx2))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"locked\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        mtx1.unlock();</span><br><span class=\"line\">        mtx2.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>std::lock支持对多个锁锁定，并且避免死锁的出现，以下代码运行时有可能出现死锁的情况：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"built_in\">std</span>::mutex* mtx1, <span class=\"built_in\">std</span>::mutex* mtx2, <span class=\"keyword\">int</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::lock_guard&lt;<span class=\"built_in\">std</span>::mutex&gt; lock1(<span class=\"built_in\">std</span>::adopt_lock);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::lock_guard&lt;<span class=\"built_in\">std</span>::mutex&gt; lock2(<span class=\"built_in\">std</span>::adopt_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; index &lt;&lt; <span class=\"string\">\"out\\n\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::mutex mtx1;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::mutex mtx2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 两个线程的互斥量锁定顺序不同，可能造成死锁</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(func, &amp;mtx1, &amp;mtx2, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t2</span><span class=\"params\">(func, &amp;mtx2, &amp;mtx1, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    t1.join();</span><br><span class=\"line\">    t2.join();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而用std::lock能避免多个锁出现死锁：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"built_in\">std</span>::mutex* mtx1, <span class=\"built_in\">std</span>::mutex* mtx2, <span class=\"keyword\">int</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::lock(*mtx1, *mtx2); <span class=\"comment\">// 同时锁定</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// std::adopt_lock作用是声明互斥量已在本线程锁定，std::lock_guard只是保证互斥量在作用域结束时被释放</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::lock_guard&lt;<span class=\"built_in\">std</span>::mutex&gt; lock1(*mtx1, <span class=\"built_in\">std</span>::adopt_lock);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::lock_guard&lt;<span class=\"built_in\">std</span>::mutex&gt; lock2(*mtx2, <span class=\"built_in\">std</span>::adopt_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等价方法：</span></span><br><span class=\"line\">    <span class=\"comment\">//std::unique_lock&lt;std::mutex&gt; lock1(from.m, std::defer_lock);</span></span><br><span class=\"line\">    <span class=\"comment\">//std::unique_lock&lt;std::mutex&gt; lock2(to.m, std::defer_lock);</span></span><br><span class=\"line\">    <span class=\"comment\">//std::lock(lock1, lock2);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; index &lt;&lt; <span class=\"string\">\"out\\n\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::mutex mtx1;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::mutex mtx2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(func, &amp;mtx1, &amp;mtx2, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\">thread <span class=\"title\">t2</span><span class=\"params\">(func, &amp;mtx2, &amp;mtx1, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    t1.join();</span><br><span class=\"line\">    t2.join();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","next":{"title":"多线程编程-条件变量","slug":"多线程编程-条件变量"},"link":"http://yoursite.com/post/多线程编程-互斥锁/"}