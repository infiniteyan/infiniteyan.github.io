{"title":"右值引用、move、emplace、emplace_back原理和用法详解","date":"2020-03-23T13:38:37.000Z","slug":"右值引用、move、emplace、emplace-back原理和用法详解","comments":true,"updated":"2020-03-23T13:51:47.553Z","content":"<h3 id=\"右值引用\">右值引用<a href=\"post/右值引用、move、emplace、emplace-back原理和用法详解#右值引用\"></a></h3><p>C++11引入了右值引用，用&amp;&amp;表示右值引用，如int &amp;&amp;a = add(1,2)。<br>先了解下什么是左值和右值，简单的说，下面的表达式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 10;</span><br></pre></td></tr></table></figure></p>\n<p>等号“=”左边的a为左值，右边的10为右值；当然这只是表面的定义，进一步说，左值是有固定的内存地址，&amp;a即左值的地址，我们可以把&amp;a保存起来，后续通过&amp;a这个地址读取、修改a的内容；而右值是一种临时的值，我们很难获取到右值的地址，如上面的10，10的地址在哪里呢，通过常规的代码是很难获取到10的内存地址的，或者即使获取到右值的地址，该地址可能很快失效了，不能后续使用了。几种常见的右值如下：</p>\n<ul>\n<li>硬编码的字面量，如int a =10中的10，char *s = “hello world”中的“hello world”都是右值</li>\n<li>函数的返回值，如add(1,2)的返回值3也是右值，这里的3是临时值</li>\n<li>表达式的计算值，如int a =1,b =2;int c = a+b;中的a+b的值也是右值，这里a+b的值也是临时值</li>\n</ul>\n<h3 id=\"移动构造函数：转移类成员的所有权\">移动构造函数：转移类成员的所有权<a href=\"post/右值引用、move、emplace、emplace-back原理和用法详解#移动构造函数：转移类成员的所有权\"></a></h3><p>C++11之前已经有复制构造函数了，相比复制构造函数，移动构造函数不是复制，而是直接转移类成员的所有权<br>C++11引入了右值引用后，水道渠成的引入了移动构造函数,其参数类型为右值引用，看下面的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\"></span><br><span class=\"line\">A(A &amp;&amp;o)&#123;</span><br><span class=\"line\">  cout&lt;&lt;&quot;move constructor&quot;&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A(const A&amp; o) &#123;</span><br><span class=\"line\">  cout&lt;&lt;&quot;copy constructor&quot;&lt;&lt;endl;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>移动构造函数和复制构造函数比较像，它把复制构造函数的&amp;替换为&amp;&amp;了，且没有了const。<br>移动构造函数有什么用呢，我们顾名思义一下，它是用来移动的，移动什么内容呢，移动的是类内部成员/元素的所有权，看下面的例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\"></span><br><span class=\"line\">A(int size) &#123;</span><br><span class=\"line\">  cout&lt;&lt;&quot;constructor&quot;&lt;&lt;endl;</span><br><span class=\"line\">  this-&gt;size = size;</span><br><span class=\"line\">  if(size)data = new int\\[size\\];</span><br><span class=\"line\">  for (int i = 0; i &lt; size; ++i)data\\[i\\] = i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A(const A&amp; o) &#123;</span><br><span class=\"line\">  cout&lt;&lt;&quot;copy constructor&quot;&lt;&lt;endl;</span><br><span class=\"line\">  this-&gt;size=o.size;</span><br><span class=\"line\">  data = new int\\[size\\];</span><br><span class=\"line\">  memcpy(data,o.data,size*sizeof(int));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A(A &amp;&amp;o) &#123;</span><br><span class=\"line\">  cout&lt;&lt;&quot;move constructor&quot;&lt;&lt;endl;</span><br><span class=\"line\">  data=o.data;</span><br><span class=\"line\">  this-&gt;size=o.size;</span><br><span class=\"line\">  o.data=nullptr;</span><br><span class=\"line\">  o.size=0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">~A()&#123;delete \\[\\]data;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">  int *data = nullptr;</span><br><span class=\"line\">  int size = 0;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在上面的复制构造函数中，我们把o.data的内容复制给this-&gt;data，这就是大家常说的深拷贝；<br>而在上面的在移动构造函数中，我们没有复制o.data的元素，而只是把o.data的指针赋值给this-&gt;data,这就是大家常用的浅拷贝，但是与浅拷贝不同的是，移动构造函数还把o.data指针置为空，这样执行移动构造函数后，this-&gt;data获得了元素的所有权，而o.data不再拥有之前元素的所有权，o.data元素的所有权被移动/过继给this了，这就是移动构造函数的含义。<br>明白了什么是移动构造函数，那么问题来了，如何才能调用移动构造函数呢?<br>当我们执行如下的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a(10);</span><br><span class=\"line\">A b = a;</span><br><span class=\"line\">//输出结果为：</span><br><span class=\"line\">constructor</span><br><span class=\"line\">copy constructor</span><br></pre></td></tr></table></figure></p>\n<p>此时调用的是复制构造函数，因为上述代码是要把a的内容复制给b；而移动构造函数的参数类型是右值引用，要想调用移动构造函数，我们需要传入一个右值引用。前面提到，函数的返回值是临时值，它是右值引用，所以我们编写一个函数，让该函数的返回类型为A，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A CreateA(int size) &#123;</span><br><span class=\"line\">  A a(size);</span><br><span class=\"line\">  return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">b = CreateA(10);</span><br><span class=\"line\">//输出结果为：</span><br><span class=\"line\">constructor</span><br><span class=\"line\">move constructor</span><br></pre></td></tr></table></figure></p>\n<p>顺利调用了移动构造函数！为了更方便的调用移动构造函数，C++11还引入了一个特别有用的函数，即std::move。</p>\n<h3 id=\"std-move把左值引用“强制转换”为右值引用\">std::move把左值引用“强制转换”为右值引用<a href=\"post/右值引用、move、emplace、emplace-back原理和用法详解#std-move把左值引用“强制转换”为右值引用\"></a></h3><p>move函数的声明如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt; class T &gt;</span><br><span class=\"line\">typename std::remove_reference&lt;T&gt;::type&amp;&amp; move( T&amp;&amp; t ) noexcept;</span><br></pre></td></tr></table></figure></p>\n<p>从函数声明上看move的返回值，返回值是右值引用，所以通过move，我们可以把左值转换为右值引用。<br>我们使用move修改上面的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a(10);</span><br><span class=\"line\">A b = std::move(a);</span><br><span class=\"line\">//输出结果为：</span><br><span class=\"line\">constructor</span><br><span class=\"line\">move constructor</span><br></pre></td></tr></table></figure></p>\n<p>顺利调用了移动构造函数，而且更简单了</p>\n<h3 id=\"具有复制功能的移动构造函数\">具有复制功能的移动构造函数<a href=\"post/右值引用、move、emplace、emplace-back原理和用法详解#具有复制功能的移动构造函数\"></a></h3><p>有童鞋问了，上面代码中的移动构造函数的移动功能，完全取决与代码的实现，假如把移动构造函数编码为复制功能，所谓的移动构造函数还算哪门子移动啊？代码如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">   A(A &amp;&amp;o) &#123;</span><br><span class=\"line\">     cout &lt;&lt; &quot;moving constructor but execute copyping&quot; &lt;&lt; endl;</span><br><span class=\"line\">     this-&gt;size = o.size;</span><br><span class=\"line\">     data = new int\\[size\\];</span><br><span class=\"line\">     memcpy(data, o.data, size * sizeof(int));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行如下的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a(10);</span><br><span class=\"line\">A b = std::move(a);</span><br><span class=\"line\">//输出结果为：</span><br><span class=\"line\">constructor</span><br><span class=\"line\">moving constructor but execute copyping</span><br></pre></td></tr></table></figure></p>\n<p>对，你没看错，在移动构造函数不执行移动，而执行复制是合法，因为移动构造函数执行移动功能只是约定，而不是强制要求，你完全可以在移动构造函数中执行复制功能！<br>但是，最好不要这么干（移动构造函数中执行复制功能，简直就是给自己挖坑！），而是遵守通用的约定，比如标准库STL中，移动构造函数都是按照约定，实现为移动功能，看下面的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; v1=&#123;1,2,3,4,5&#125;;</span><br><span class=\"line\">vector&lt;int&gt; v2=move(v1);</span><br><span class=\"line\">cout&lt;&lt;&quot;v1.size:&quot;&lt;&lt;v1.size()&lt;&lt;endl;</span><br><span class=\"line\">cout&lt;&lt;&quot;v2.size:&quot;&lt;&lt;v2.size()&lt;&lt;endl;</span><br><span class=\"line\">//执行结果为：</span><br><span class=\"line\">v1.size:0</span><br><span class=\"line\">v2.size:5</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"emplace更高效的向STL容器插入元素\">emplace更高效的向STL容器插入元素<a href=\"post/右值引用、move、emplace、emplace-back原理和用法详解#emplace更高效的向STL容器插入元素\"></a></h3><p>“移动式”插入元素emplace_back/emplace：更高效的向STL容器插入元素<br>先看下vector::push_back插入元素的过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;A&gt; vec;</span><br><span class=\"line\">A a(10);</span><br><span class=\"line\">vec.push_back(a);</span><br><span class=\"line\">//输出结果为：</span><br><span class=\"line\">constructor</span><br><span class=\"line\">copy constructor</span><br></pre></td></tr></table></figure></p>\n<p>从输出结果看，push_back过程中除了调用一次构造函数，还额外调用了一次复制构造函数，额外调用复制构造函数甚是浪费时间，假如是A a(10000000)，复制起来可是非常耗时的！如何避免额外的复制呢？emplace_back来帮助你，其函数声明如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt; class... Args &gt;</span><br><span class=\"line\">void emplace_back( Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure></p>\n<p>从函数声明中，我们看到其参数是右值引用，右值引用可以用来干什么？移动元素的所有权！让我们执行下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;A&gt; vec;</span><br><span class=\"line\">A a(10);</span><br><span class=\"line\">vec.emplace_back(std::move(a));</span><br><span class=\"line\">//输出结果为：</span><br><span class=\"line\">constructor</span><br><span class=\"line\">move constructor</span><br></pre></td></tr></table></figure></p>\n<p>从输出结果看，此时调用了一次构造函数，和一次移动构造函数，而移动构造函数基本是不耗时的。很明显，使用emplace_back比push_back效率更高。<br>另外，C++11中，上面的代码可以简化为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;A&gt; vec;</span><br><span class=\"line\">vec.emplace_back(10);</span><br><span class=\"line\">//输出结果为:</span><br><span class=\"line\">constructor</span><br></pre></td></tr></table></figure></p>\n<p>从输出结果看，此时只调用了一次构造函数，连移动构造函数都省掉了，这是因为emplace_back把参数10完美转发给A的构造函数，直接构造了一个元素，而这个元素是直接存放在vector容器中的。</p>\n<p>简单总结一下，push_back是“复制式”(即调用复制构造函数)的插入元素，而emplace_back是“移动式”(即调用移动构造函数)的插入元素；<br>同理，vector::insert、set::insert、map::insert是复制式的插入元素，他们的移动式插入函数是emplace<br>两个注意事项：<br>调用emplace_back时需要注意，不要把vec.emplace_back(std::move(a))，错误的写成vec.emplace_back(a)，看下面的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;A&gt; vec;</span><br><span class=\"line\">A a(10);</span><br><span class=\"line\">vec.emplace_back(a);</span><br><span class=\"line\">//输出的结果为：</span><br><span class=\"line\">constructor</span><br><span class=\"line\">copy constructor</span><br></pre></td></tr></table></figure></p>\n<p>从输出结果看，此时调用的是复制构造函数而不是移动构造函数，因为传入的参数a不是右值引用，需要先调用a的复制构造函数生成一个副本，然后把副本的右值引用传递给emplace_back，最终造成vec.emplace_back(a)等效与vec.push_back(a)。<br>当自定义类A没有移动构造函数时，vec.emplace_back(std::move(a))也等效与vec.push_back(a)。</p>\n","next":{"title":"Algorithm-Problem-简化路径","slug":"Algorithm-Problem-简化路径"},"link":"http://yoursite.com/post/右值引用、move、emplace、emplace-back原理和用法详解/"}