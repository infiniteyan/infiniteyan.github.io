{"title":"GO语言新手可能会踩的50个坑（三）","date":"2019-05-11T08:49:52.000Z","slug":"GO语言新手可能会踩的50个坑（三）","comments":true,"updated":"2019-05-11T09:07:49.698Z","content":"<h4 id=\"21-在多行-array、slice、map-语句中缺少-号\">21.在多行 array、slice、map 语句中缺少 , 号<a href=\"post/GO语言新手可能会踩的50个坑（三）#21-在多行-array、slice、map-语句中缺少-号\"></a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := []int &#123;</span><br><span class=\"line\">        1,</span><br><span class=\"line\">        2    // syntax error: unexpected newline, expecting comma or &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    y := []int&#123;1,2,&#125;    </span><br><span class=\"line\">    z := []int&#123;1,2&#125;    </span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>声明语句中 } 折叠到单行后，尾部的 , 不是必需的。</p>\n<h4 id=\"22-log-Fatal-和-log-Panic-不只是-log\">22.log.Fatal 和 log.Panic 不只是 log<a href=\"post/GO语言新手可能会踩的50个坑（三）#22-log-Fatal-和-log-Panic-不只是-log\"></a></h4><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 Fatal<em>()、Panic</em>() 时能做更多日志外的事，如中断程序的执行等：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    log.Fatal(&quot;Fatal level log: log entry&quot;)        // 输出信息后，程序终止执行</span><br><span class=\"line\">    log.Println(&quot;Nomal level log: log entry&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"23-对内建数据结构的操作并不是同步的\">23.对内建数据结构的操作并不是同步的<a href=\"post/GO语言新手可能会踩的50个坑（三）#23-对内建数据结构的操作并不是同步的\"></a></h4><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。<br>goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。</p>\n<h4 id=\"24-range-迭代-string-得到的值\">24.range 迭代 string 得到的值<a href=\"post/GO语言新手可能会踩的50个坑（三）#24-range-迭代-string-得到的值\"></a></h4><p>range 得到的索引是字符值（Unicode point / rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。<br>注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用norm 包。<br>for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。</p>\n<h4 id=\"25-range-迭代-map\">25.range 迭代 map<a href=\"post/GO语言新手可能会踩的50个坑（三）#25-range-迭代-map\"></a></h4><p>如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。<br>Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    m := map[string]int&#123;&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3, &quot;four&quot;: 4&#125;</span><br><span class=\"line\">    for k, v := range m &#123;</span><br><span class=\"line\">        fmt.Println(k, v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果你去 Go Playground 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的。</p>\n<h4 id=\"26-switch-中的-fallthrough-语句\">26.switch 中的 fallthrough 语句<a href=\"post/GO语言新手可能会踩的50个坑（三）#26-switch-中的-fallthrough-语句\"></a></h4><p>switch 语句中的 case 代码块会默认带上 break，但可以使用 fallthrough 来强制执行下一个 case 代码块。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    isSpace := func(char byte) bool &#123;</span><br><span class=\"line\">        switch char &#123;</span><br><span class=\"line\">        case &apos; &apos;:    // 空格符会直接 break，返回 false // 和其他语言不一样</span><br><span class=\"line\">        // fallthrough    // 返回 true</span><br><span class=\"line\">        case &apos;\\t&apos;:</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(isSpace(&apos;\\t&apos;))    // true</span><br><span class=\"line\">    fmt.Println(isSpace(&apos; &apos;))    // false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;fmt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tisSpace := func(char byte) bool &#123;</span><br><span class=\"line\">\t\tswitch char &#123;</span><br><span class=\"line\">\t\tcase &apos; &apos;:</span><br><span class=\"line\">\t\t\tfallthrough</span><br><span class=\"line\">\t\tcase &apos;\\t&apos;:</span><br><span class=\"line\">\t\t\treturn true</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn false</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(isSpace(&apos;\\t&apos;))    // true</span><br><span class=\"line\">\tfmt.Println(isSpace(&apos; &apos;))     // true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"27-自增和自减运算\">27.自增和自减运算<a href=\"post/GO语言新手可能会踩的50个坑（三）#27-自增和自减运算\"></a></h4><p>很多编程语言都自带前置后置的 ++、– 运算。但 Go 特立独行，去掉了前置操作，同时 ++、— 只作为运算符而非表达式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 错误示例</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    data := []int&#123;1, 2, 3&#125;</span><br><span class=\"line\">    i := 0</span><br><span class=\"line\">    ++i            // syntax error: unexpected ++, expecting &#125;</span><br><span class=\"line\">    fmt.Println(data[i++])    // syntax error: unexpected ++, expecting :</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 正确示例</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    data := []int&#123;1, 2, 3&#125;</span><br><span class=\"line\">    i := 0</span><br><span class=\"line\">    i++</span><br><span class=\"line\">    fmt.Println(data[i])    // 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"28-按位取反\">28.按位取反<a href=\"post/GO语言新手可能会踩的50个坑（三）#28-按位取反\"></a></h4><p>很多编程语言使用 ~ 作为一元按位取反（NOT）操作符，Go 重用 ^ XOR 操作符来按位取反：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 错误的取反操作</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    fmt.Println(~2)        // bitwise complement operator is ^</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 正确示例</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var d uint8 = 2</span><br><span class=\"line\">    fmt.Printf(&quot;%08b\\n&quot;, d)        // 00000010</span><br><span class=\"line\">    fmt.Printf(&quot;%08b\\n&quot;, ^d)    // 11111101</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同时 ^ 也是按位异或（XOR）操作符。</p>\n<h4 id=\"29-运算符的优先级\">29.运算符的优先级<a href=\"post/GO语言新手可能会踩的50个坑（三）#29-运算符的优先级\"></a></h4><p>除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;0x2 &amp; 0x2 + 0x4 -&gt; %#x\\n&quot;, 0x2&amp;0x2+0x4)    // &amp; 优先 +</span><br><span class=\"line\">    //prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6</span><br><span class=\"line\">    //Go:    (0x2 &amp; 0x2) + 0x4</span><br><span class=\"line\">    //C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(&quot;0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\\n&quot;, 0x2+0x2&lt;&lt;0x1)    // &lt;&lt; 优先 +</span><br><span class=\"line\">    //prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span><br><span class=\"line\">    //Go:     0x2 + (0x2 &lt;&lt; 0x1)</span><br><span class=\"line\">    //C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(&quot;0xf | 0x2 ^ 0x2 -&gt; %#x\\n&quot;, 0xf|0x2^0x2)    // | 优先 ^</span><br><span class=\"line\">    //prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span><br><span class=\"line\">    //Go:    (0xf | 0x2) ^ 0x2</span><br><span class=\"line\">    //C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>优先级列表：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Precedence    Operator</span><br><span class=\"line\">    5             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class=\"line\">    4             +  -  |  ^</span><br><span class=\"line\">    3             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class=\"line\">    2             &amp;&amp;</span><br><span class=\"line\">    1             ||</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"30-不导出的-struct-字段无法被-encode\">30.不导出的 struct 字段无法被 encode<a href=\"post/GO语言新手可能会踩的50个坑（三）#30-不导出的-struct-字段无法被-encode\"></a></h4><p>以小写字母开头的字段成员是无法被外部直接访问的，所以 struct 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    in := MyData&#123;1, &quot;two&quot;&#125;</span><br><span class=\"line\">    fmt.Printf(&quot;%#v\\n&quot;, in)    // main.MyData&#123;One:1, two:&quot;two&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    encoded, _ := json.Marshal(in)</span><br><span class=\"line\">    fmt.Println(string(encoded))    // &#123;&quot;One&quot;:1&#125;    // 私有字段 two 被忽略了</span><br><span class=\"line\"></span><br><span class=\"line\">    var out MyData</span><br><span class=\"line\">    json.Unmarshal(encoded, &amp;out)</span><br><span class=\"line\">    fmt.Printf(&quot;%#v\\n&quot;, out)     // main.MyData&#123;One:1, two:&quot;&quot;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","next":{"title":"GO语言新手可能会踩的50个坑（二）","slug":"GO语言新手可能会踩的50个坑（二）"},"link":"http://yoursite.com/post/GO语言新手可能会踩的50个坑（三）/"}