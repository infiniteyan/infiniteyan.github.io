{"title":"GO单元测试、基准测试","date":"2019-05-22T05:14:48.000Z","slug":"GO单元测试、基准测试","comments":true,"updated":"2019-05-22T05:26:10.213Z","content":"<p>通过测试，我们能够及时的发现我们程序的设计逻辑错误，并能够给接手项目的其它程序员同学理解函数有帮助。<br>本篇文章主要介绍 Go 语言中的 testing 包。它要求我们以 *_test.go 新建文件，并在文件中以 TestXxx 命名函数。然后再通过 go test [flags] [packages] 执行函数。它也为我们提供了三种类型的函数：测试函数 T、基准测试函数 B、实例函数 Example。</p>\n<h4 id=\"Test测试\">Test测试<a href=\"post/GO单元测试、基准测试#Test测试\"></a></h4><p>函数测试，其基本签名是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func TestName(t *testing.T)&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试函数的名字必须以 Test 开头，可选的后缀名必须不以小写字母开头，一般跟我们测试的函数名。<br>类型 testing.T 有以下方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 打印日志。对于测试，会在失败或指定 -test.v 标志时打印。对与基准测试，总是打印，避免因未指定 -test.v 带来的测试不准确</span><br><span class=\"line\">func (c *T) Log(args ...interface&#123;&#125;)</span><br><span class=\"line\">func (c *T) Logf(format string, args ...interface&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 标记函数失败，继续执行该函数</span><br><span class=\"line\">func (c *T) Fail()</span><br><span class=\"line\">// 标记函数失败，调用 runtime.Goexit 退出该函数。但继续执行其它函数或基准测试。</span><br><span class=\"line\">func (c *T) FailNow()</span><br><span class=\"line\">// 返回函数是否失败</span><br><span class=\"line\">func (c *T) Failed() bool</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于 t.Log + t.Fail</span><br><span class=\"line\">func (c *T) Error(args ...interface&#123;&#125;)</span><br><span class=\"line\">// 等同于 t.Logf + t.Fail</span><br><span class=\"line\">func (c *T) Errorf(format string, args ...interface&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于 t.Log + t.FailNow</span><br><span class=\"line\">func (c *T) Fatal(args ...interface&#123;&#125;)</span><br><span class=\"line\">// 等同于 t.Logf + t.FailNow</span><br><span class=\"line\">func (c *T) Fatalf(format string, args ...interface&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 将调用函数标记标记为测试助手函数。</span><br><span class=\"line\">func (c *T) Helper()</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回正在运行的测试或基准测试的名称</span><br><span class=\"line\">func (c *T) Name() string</span><br><span class=\"line\"></span><br><span class=\"line\">// 用于表示当前测试只会与其他带有 Parallel 方法的测试并行进行测试。</span><br><span class=\"line\">func (t *T) Parallel()</span><br><span class=\"line\"></span><br><span class=\"line\">// 执行名字为 name 的子测试 f，并报告 f 在执行过程中是否失败</span><br><span class=\"line\">// Run 会阻塞到 f 的所有并行测试执行完毕。</span><br><span class=\"line\">func (t *T) Run(name string, f func(t *T)) bool</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 相当于 t.Log + t. SkipNow</span><br><span class=\"line\">func (c *T) Skip(args ...interface&#123;&#125;)</span><br><span class=\"line\">// 将测试标记为跳过，并调用 runtime.Goexit 退出该测试。继续执行其它测试或基准测试</span><br><span class=\"line\">func (c *T) SkipNow()</span><br><span class=\"line\">// 相当于 t.Logf + t.SkipNow</span><br><span class=\"line\">func (c *T) Skipf(format string, args ...interface&#123;&#125;)</span><br><span class=\"line\">// 报告该测试是否是忽略</span><br><span class=\"line\">func (c *T) Skipped() bool</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Benchmark-测试\">Benchmark 测试<a href=\"post/GO单元测试、基准测试#Benchmark-测试\"></a></h4><p>函数测试，其基本签名是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func BenchmarkName(b *testing.B)&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试函数的名字必须以 Benchmark 开头，可选的后缀名必须不以小写字母开头，一般跟我们测试的函数名。<br>B 类型有一个参数 N，它可以用来执行基准测试的迭代运行的次数。基准测试与测试，基准测试总是会输出日志。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type B struct &#123;</span><br><span class=\"line\">    N int</span><br><span class=\"line\">    // contains filtered or unexported fields</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>基准测试较测试多了些函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (c *B) Log(args ...interface&#123;&#125;)</span><br><span class=\"line\">func (c *B) Logf(format string, args ...interface&#123;&#125;)</span><br><span class=\"line\">func (c *B) Fail()</span><br><span class=\"line\">func (c *B) FailNow()</span><br><span class=\"line\">func (c *B) Failed() bool</span><br><span class=\"line\">func (c *B) Error(args ...interface&#123;&#125;)</span><br><span class=\"line\">func (c *B) Errorf(format string, args ...interface&#123;&#125;)</span><br><span class=\"line\">func (c *B) Fatal(args ...interface&#123;&#125;)</span><br><span class=\"line\">func (c *B) Fatalf(format string, args ...interface&#123;&#125;)</span><br><span class=\"line\">func (c *B) Helper()</span><br><span class=\"line\">func (c *B) Name() string</span><br><span class=\"line\">func (b *B) Run(name string, f func(b *B)) bool</span><br><span class=\"line\">func (c *B) Skip(args ...interface&#123;&#125;)</span><br><span class=\"line\">func (c *B) SkipNow()</span><br><span class=\"line\">func (c *B) Skipf(format string, args ...interface&#123;&#125;)</span><br><span class=\"line\">func (c *B) Skipped() bool</span><br><span class=\"line\"></span><br><span class=\"line\">// 打开当前基准测试的内存统计功能，与使用 -test.benchmem 设置类似，</span><br><span class=\"line\">// 但 ReportAllocs 只影响那些调用了该函数的基准测试。</span><br><span class=\"line\">func (b *B) ReportAllocs()</span><br><span class=\"line\"></span><br><span class=\"line\">// 对已经逝去的基准测试时间以及内存分配计数器进行清零。对于正在运行中的计时器，这个方法不会产生任何效果。</span><br><span class=\"line\">func (b *B) ResetTimer()</span><br><span class=\"line\">例：</span><br><span class=\"line\">func BenchmarkBigLen(b *testing.B) &#123;</span><br><span class=\"line\">    big := NewBig()</span><br><span class=\"line\">    b.ResetTimer()</span><br><span class=\"line\">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class=\"line\">        big.Len()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 以并行的方式执行给定的基准测试。RunParallel 会创建出多个 goroutine，并将 b.N 个迭代分配给这些 goroutine 执行，</span><br><span class=\"line\">// 其中 goroutine 数量的默认值为 GOMAXPROCS。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性，</span><br><span class=\"line\">// 那么可以在 RunParallel 之前调用 SetParallelism。RunParallel 通常会与 -cpu 标志一同使用。</span><br><span class=\"line\">// body 函数将在每个 goroutine 中执行，这个函数需要设置所有 goroutine 本地的状态，</span><br><span class=\"line\">// 并迭代直到 pb.Next 返回 false 值为止。因为 StartTimer、StopTimer 和 ResetTimer 这三个函数都带有全局作用，所以 body函数不应该调用这些函数；</span><br><span class=\"line\">// 除此之外，body 函数也不应该调用 Run 函数。</span><br><span class=\"line\">func (b *B) RunParallel(body func(*PB))</span><br><span class=\"line\">例：</span><br><span class=\"line\">func BenchmarkTemplateParallel(b *testing.B) &#123;</span><br><span class=\"line\">    templ := template.Must(template.New(&quot;test&quot;).Parse(&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;))</span><br><span class=\"line\">    b.RunParallel(func(pb *testing.PB) &#123;</span><br><span class=\"line\">        var buf bytes.Buffer</span><br><span class=\"line\">        for pb.Next() &#123;</span><br><span class=\"line\">            buf.Reset()</span><br><span class=\"line\">            templ.Execute(&amp;buf, &quot;World&quot;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 记录在单个操作中处理的字节数量。 在调用了这个方法之后， 基准测试将会报告 ns/op 以及 MB/s</span><br><span class=\"line\">func (b *B) SetBytes(n int64)</span><br><span class=\"line\"></span><br><span class=\"line\">// 将 RunParallel 使用的 goroutine 数量设置为 p*GOMAXPROCS，如果 p 小于 1，那么调用将不产生任何效果。</span><br><span class=\"line\">// CPU受限（CPU-bound）的基准测试通常不需要调用这个方法。</span><br><span class=\"line\">func (b *B) SetParallelism(p int)</span><br><span class=\"line\"></span><br><span class=\"line\">// 开始对测试进行计时。</span><br><span class=\"line\">// 这个函数在基准测试开始时会自动被调用，它也可以在调用 StopTimer 之后恢复进行计时。</span><br><span class=\"line\">func (b *B) StartTimer()</span><br><span class=\"line\"></span><br><span class=\"line\">// 停止对测试进行计时。</span><br><span class=\"line\">func (b *B) StopTimer()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Example-测试\">Example 测试<a href=\"post/GO单元测试、基准测试#Example-测试\"></a></h4><p>示例函数可以帮助我们写一个示例，并与输出相比较：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func ExampleHello() &#123;</span><br><span class=\"line\">    fmt.Println(&quot;hello&quot;)</span><br><span class=\"line\">    // Output: hello</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func ExampleSalutations() &#123;</span><br><span class=\"line\">    fmt.Println(&quot;hello, and&quot;)</span><br><span class=\"line\">    fmt.Println(&quot;goodbye&quot;)</span><br><span class=\"line\">    // Output:</span><br><span class=\"line\">    // hello, and</span><br><span class=\"line\">    // goodbye</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 无序输出 Unordered output</span><br><span class=\"line\">func ExamplePerm() &#123;</span><br><span class=\"line\">    for _, value := range Perm(4) &#123;</span><br><span class=\"line\">        fmt.Println(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // Unordered output: 4</span><br><span class=\"line\">    // 2</span><br><span class=\"line\">    // 1</span><br><span class=\"line\">    // 3</span><br><span class=\"line\">    // 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于示例函数我们需要知道：<br>1.函数的签名需要以 Example 开头<br>2.输出的对比有有序（Output）和无序（Unordered output）两种<br>3.如果函数没有输出注释，将不会被执行<br>官方给我们的命名的规则是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个包的 example</span><br><span class=\"line\">func Example() &#123; ... &#125;</span><br><span class=\"line\">// 一个函数 F 的 example</span><br><span class=\"line\">func ExampleF() &#123; ... &#125;</span><br><span class=\"line\">// 一个类型 T 的 example</span><br><span class=\"line\">func ExampleT() &#123; ... &#125;</span><br><span class=\"line\">// 一个类型 T 的方法 M 的 example</span><br><span class=\"line\">func ExampleT_M() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果以上四种类型需要提供多个示例，可以通过添加后缀的方式</span><br><span class=\"line\">// 后缀必须小写</span><br><span class=\"line\">func Example_suffix() &#123; ... &#125;</span><br><span class=\"line\">func ExampleF_suffix() &#123; ... &#125;</span><br><span class=\"line\">func ExampleT_suffix() &#123; ... &#125;</span><br><span class=\"line\">func ExampleT_M_suffix() &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"子测试\">子测试<a href=\"post/GO单元测试、基准测试#子测试\"></a></h4><p>上面我们也说到了 Test 和 Benchmark 的 Run 方法，它用来执行子测试。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func TestFoo(t *testing.T) &#123;</span><br><span class=\"line\">    // &lt;setup code&gt;</span><br><span class=\"line\">    t.Run(&quot;A=1&quot;, func(t *testing.T) &#123; ... &#125;)</span><br><span class=\"line\">    t.Run(&quot;A=2&quot;, func(t *testing.T) &#123; ... &#125;)</span><br><span class=\"line\">    t.Run(&quot;B=1&quot;, func(t *testing.T) &#123; ... &#125;)</span><br><span class=\"line\">    // &lt;tear-down code&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Main测试\">Main测试<a href=\"post/GO单元测试、基准测试#Main测试\"></a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func TestMain(m *testing.M)</span><br><span class=\"line\"></span><br><span class=\"line\">例：</span><br><span class=\"line\">func TestMain(m *testing.M) &#123;</span><br><span class=\"line\">    // call flag.Parse() here if TestMain uses flags</span><br><span class=\"line\">    os.Exit(m.Run())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"HTTP测试\">HTTP测试<a href=\"post/GO单元测试、基准测试#HTTP测试\"></a></h4><p>Go 语言目前的 web 开发是比较多的，那么在我们对功能函数有了测试之后，HTTP 的测试又该怎样做呢？<br>Go 的标准库为我们提供了一个 httptest 的库，通过它就能够轻松的完成 HTTP 的测试。<br>1、测试 Handle 函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;io&quot;</span><br><span class=\"line\">    &quot;io/ioutil&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;net/http/httptest&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">var HandleHelloWorld = func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    io.WriteString(w, &quot;&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    req := httptest.NewRequest(&quot;GET&quot;, &quot;http://example.com/foo&quot;, nil)</span><br><span class=\"line\">    w := httptest.NewRecorder()</span><br><span class=\"line\">    HandleHelloWorld(w, req)</span><br><span class=\"line\"></span><br><span class=\"line\">    resp := w.Result()</span><br><span class=\"line\">    body, _ := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Println(resp.StatusCode)</span><br><span class=\"line\">    fmt.Println(resp.Header.Get(&quot;Content-Type&quot;))</span><br><span class=\"line\">    fmt.Println(string(body))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","prev":{"title":"GDB调试工具总结","slug":"GDB调试工具总结"},"next":{"title":"Iris框架MVC例子","slug":"Iris框架MVC例子"},"link":"http://yoursite.com/post/GO单元测试、基准测试/"}