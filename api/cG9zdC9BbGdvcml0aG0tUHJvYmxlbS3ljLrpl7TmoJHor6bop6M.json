{"title":"Algorithm Problem : 区间树详解","date":"2019-03-04T02:52:55.000Z","slug":"Algorithm-Problem-区间树详解","comments":true,"updated":"2019-03-04T03:07:16.791Z","content":"<h2 id=\"定义\">定义<a href=\"post/Algorithm-Problem-区间树详解#定义\"></a></h2><p>区间树 (Interval tree), 是一种二叉搜索树。它将一个区间划分成一些单元区间(即单个数据)，每个单元区间对应一个叶节点，非叶节点表示其所代表的子树对应的子区间.<br>区间树和线段树并不是一个概念，线段树是一个静态结构，用于数据存储查询，不能进行修改；而区间树是支持动修改和查询的数据结构，很多人将这两个概念混淆，并用线段树指代区间树。<br>区间树中，每个节点的子节点分别表示它的左右半区间。对于每一个非叶节点 ，设其对应区间为[a, b]，它的左子树表示的区间为[a, (a+b)/2], 右子树表示的区间为[(a+b)/2+1, b]。因此区间树是平衡二叉树, 其存储的空间复杂度是O(N) (确切说是4N-2), 操作的时间复杂度是O(logN).<br>区间树中，叶节点的value是数据，非叶节点的value是其对应区间的最小值。<br>下图给出一个以数组array构建的区间树的示例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int N = 6;</span><br><span class=\"line\">int array[N] = &#123;2, 5, 1, 4, 9, 3&#125;;</span><br></pre></td></tr></table></figure></p>\n<div class=\"article-img\"><p><img src=\"/2019/03/04/Algorithm-Problem-区间树详解/0001.jpg\" alt=\"aa\" data-zoomable></p></div>\n<h2 id=\"构建区间树\">构建区间树<a href=\"post/Algorithm-Problem-区间树详解#构建区间树\"></a></h2><p>区间树的构建采用递归方式，当前区间是单元区间时直接赋值给节点，否则，首先递归构建左右子树，然后将左右子树的最小值赋值给当前结点。其复杂度是O(N).<br>此处采用数组实现区间树，itvTree[0]是根节点，itvTree[node]的左右子为itvTree[node<em>2+1]和itvTree[node</em>2+2].<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct ItvNode &#123;</span><br><span class=\"line\">    int value;</span><br><span class=\"line\">&#125; itvTree[N*2];</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> build interval tree</span><br><span class=\"line\"> node: node index need to build</span><br><span class=\"line\"> begin: begin of the interval corresponding to node</span><br><span class=\"line\"> end: end of the interval corresponding to node, exclusive</span><br><span class=\"line\"> */</span><br><span class=\"line\">void build(int node, int begin, int end) &#123;</span><br><span class=\"line\">    if (begin == end-1) &#123;</span><br><span class=\"line\">        itvTree[node].value = array[begin];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        build(node * 2 + 1, begin, (begin + end) / 2);</span><br><span class=\"line\">        build(node * 2 + 2, (begin + end) / 2, end);</span><br><span class=\"line\">        itvTree[node].value = min(itvTree[node * 2 + 1].value, itvTree[node * 2 + 2].value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"区间查询\">区间查询<a href=\"post/Algorithm-Problem-区间树详解#区间查询\"></a></h2><p>区间查询是指，用户输入一个区间，获取该区间的相关信息，比如区间的最大值，最小值，第k大的值等。对于本文的示例程序，是获取区间的最小值。<br>若查询区间与当前结点对应区间没有交叠，返回-1. 若查询区间包含在当前区间内，返回当前结点的value。否则，对子区间递归查询，并将查询结果合并返回。查询复杂度为O(logN).<br>递归中，将查询区间不加改变的传下去，每次查询只返回包含在查询区间内的结果即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> query for minimum number of given interval</span><br><span class=\"line\"> node: node index to query</span><br><span class=\"line\"> begin: begin of the interval corresponding to node</span><br><span class=\"line\"> end: end of the interval corresponding to node, exclusive</span><br><span class=\"line\"> left: left bounce of query interval</span><br><span class=\"line\"> right: right bounce of query interval, exclusive</span><br><span class=\"line\"> */</span><br><span class=\"line\">int query(int node, int begin, int end, int left, int right) &#123;</span><br><span class=\"line\">    //[begin, end) -&gt; [left, right)</span><br><span class=\"line\">    if (left&gt;=end || right&lt;=begin) &#123;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (left &lt;= begin &amp;&amp; end &lt;= right) &#123;</span><br><span class=\"line\">        return itvTree[node].value; //return node&apos;s value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //recusive query</span><br><span class=\"line\">    int res1 = query(node * 2 + 1, begin, (begin + end) / 2, left, right);</span><br><span class=\"line\">    int res2 = query(node * 2 + 2, (begin + end) / 2, end, left, right);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(res1 == -1) &#123;</span><br><span class=\"line\">    \treturn res2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(res2 == -1) &#123;</span><br><span class=\"line\">    \treturn res1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return min(res1, res2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"节点更新-amp-区间更新-amp-动态维护\">节点更新 &amp; 区间更新 &amp; 动态维护<a href=\"post/Algorithm-Problem-区间树详解#节点更新-amp-区间更新-amp-动态维护\"></a></h2><p>a. 节点更新<br>更新一个节点的value时，除了需要更新节点值，还要递归的更新其父节点，时间复杂度为O(logN).<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> update a node&apos;s value</span><br><span class=\"line\"> node: root node of current sub-tree</span><br><span class=\"line\"> left: left bounce of query interval</span><br><span class=\"line\"> right: right bounce of query interval, exclusive</span><br><span class=\"line\"> index: index of array need to be updated</span><br><span class=\"line\"> value: new value</span><br><span class=\"line\"> */</span><br><span class=\"line\">void update(int node, int begin, int end, int index, int value) &#123;</span><br><span class=\"line\">    if(begin == end-1) &#123;</span><br><span class=\"line\">        itvTree[node].value = value;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        int mid = (begin + end) &gt;&gt; 1;</span><br><span class=\"line\">        if (index &lt; mid) &#123;</span><br><span class=\"line\">            update(node * 2 + 1, begin, mid, index, value);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            update(node * 2 + 2, mid, end, index, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //update father node</span><br><span class=\"line\">        itvTree[node].value = min(itvTree[node * 2 + 1].value, itvTree[node * 2 + 2].value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>b.区间更新<br>区间更新是指更新某个区间内的叶子节点的值，同时涉及到的非叶节点也需要同时更新。但是因为需要更新的节点很多，其复杂度将大于O(logN)。因此引入延迟标记的概念，这也是区间树的精髓。<br>延迟标记：每个节点增加一个标记，用于记录该节点是否进行了某种修改。当进行区间更新时，按照区间查询的方式，将更新区间划分为区间树中的节点，对这些修改这些.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct ItvNode &#123;</span><br><span class=\"line\">    int value;</span><br><span class=\"line\">    int mark;</span><br><span class=\"line\">&#125; itvTree[N * 2];</span><br><span class=\"line\"></span><br><span class=\"line\">void build(int node, int begin, int end) &#123;</span><br><span class=\"line\">    itvTree[node].mark = 0;</span><br><span class=\"line\">    if (begin == end-1) &#123; </span><br><span class=\"line\">        itvTree[node].value = array[begin];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        build(node * 2 + 1, begin, (begin + end) / 2);</span><br><span class=\"line\">        build(node * 2 + 2, (begin + end) / 2, end);</span><br><span class=\"line\">        itvTree[node].value = min(itvTree[node * 2 + 1].value, itvTree[node * 2 + 2].value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void pushDown(int node) &#123;</span><br><span class=\"line\">    if (itvTree[node].mark != 0) &#123;</span><br><span class=\"line\">        itvTree[node * 2 + 1].mark += itvTree[node].mark;</span><br><span class=\"line\">        itvTree[node * 2 + 2].mark += itvTree[node].mark;</span><br><span class=\"line\"></span><br><span class=\"line\">        itvTree[node * 2 + 1].value += itvTree[node].mark;</span><br><span class=\"line\">        itvTree[node * 2 + 2].value += itvTree[node].mark;</span><br><span class=\"line\"></span><br><span class=\"line\">        itvTree[node].mark = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int query(int node, int begin, int end, int left, int right) &#123;</span><br><span class=\"line\">    if (left &gt;= end || right &lt;= begin) &#123;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (left &lt;= begin &amp;&amp; end &lt;= right) &#123;</span><br><span class=\"line\">        return itvTree[node].value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pushDown(node);</span><br><span class=\"line\"></span><br><span class=\"line\">    int res1 = query(node * 2 + 1, begin, (begin + end) / 2, left, right);</span><br><span class=\"line\">    int res2 = quert(node * 2 + 2, (begin + end) / 2, end, left, right);</span><br><span class=\"line\">    if (res1 == -1) &#123;</span><br><span class=\"line\">    \treturn res2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (res2 == -1) &#123;</span><br><span class=\"line\">    \treturn res1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return min(res1, res2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void update(int node, int begin, int end, int left, int right, int mark) &#123;</span><br><span class=\"line\">    if (left &gt;= end || right &lt;= begin) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (left &lt;= begin &amp;&amp; end &lt;= right) &#123;</span><br><span class=\"line\">        itvTree[node].value += mark;    //update node&apos;s value first</span><br><span class=\"line\">        itvTree[node].mark += mark;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pushDown(node); //push previous update down</span><br><span class=\"line\"></span><br><span class=\"line\">    update(node * 2 + 1, begin, (begin + end) / 2, left, right, mark);</span><br><span class=\"line\">    update(node * 2 + 2, (begin + end) / 2, end, left, right, mark);</span><br><span class=\"line\">    itvTree[node].value = min(itvTree[node * 2 + 1].value, itvTree[node * 2 + 2].value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"区间树应用\">区间树应用<a href=\"post/Algorithm-Problem-区间树详解#区间树应用\"></a></h2><ul>\n<li>区间最值查询(RMQ, Range Minimum/Maximum Query)</li>\n<li>单节点更新或连续区间修改的动态查询</li>\n<li>多维空间动态查询</li>\n</ul>\n","next":{"title":"Algorithm Problem : 并查集详解","slug":"Algorithm-Problem-并查集详解"},"link":"http://yoursite.com/post/Algorithm-Problem-区间树详解/","toc":[{"title":"定义","id":"定义","index":"1"},{"title":"构建区间树","id":"构建区间树","index":"2"},{"title":"区间查询","id":"区间查询","index":"3"},{"title":"节点更新 &amp; 区间更新 &amp; 动态维护","id":"节点更新-amp-区间更新-amp-动态维护","index":"4"},{"title":"区间树应用","id":"区间树应用","index":"5"}]}