{"title":"GO语言新手可能会踩的50个坑（二）","date":"2019-05-11T05:54:32.000Z","slug":"GO语言新手可能会踩的50个坑（二）","comments":true,"updated":"2019-05-11T06:33:39.030Z","content":"<h4 id=\"11-string类型的变量值不能为-nil\">11.string类型的变量值不能为 nil<a href=\"post/GO语言新手可能会踩的50个坑（二）#11-string类型的变量值不能为-nil\"></a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 错误示例</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var s string = nil    // cannot use nil as type string in assignment</span><br><span class=\"line\">    if s == nil &#123;    // invalid operation: s == nil (mismatched types string and nil)</span><br><span class=\"line\">        s = &quot;default&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 正确示例</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var s string    // 字符串类型的零值是空串 &quot;&quot;</span><br><span class=\"line\">    if s == &quot;&quot; &#123;</span><br><span class=\"line\">        s = &quot;default&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"12-Array-类型的值作为函数参数\">12. Array 类型的值作为函数参数<a href=\"post/GO语言新手可能会踩的50个坑（二）#12-Array-类型的值作为函数参数\"></a></h4><p>在 C/C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。<br>在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 数组使用值拷贝传参</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := [3]int&#123;1,2,3&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func(arr [3]int) &#123;</span><br><span class=\"line\">        arr[0] = 7</span><br><span class=\"line\">        fmt.Println(arr)    // [7 2 3]</span><br><span class=\"line\">    &#125;(x)</span><br><span class=\"line\">    fmt.Println(x)            // [1 2 3]    // 并不是你以为的 [7 2 3]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果想修改参数数组，直接传递指向这个数组的指针类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 传址会修改原数据</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := [3]int&#123;1,2,3&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func(arr *[3]int) &#123;</span><br><span class=\"line\">        (*arr)[0] = 7    </span><br><span class=\"line\">        fmt.Println(arr)    // &amp;[7 2 3]</span><br><span class=\"line\">    &#125;(&amp;x)</span><br><span class=\"line\">    fmt.Println(x)    // [7 2 3]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 会修改 slice 的底层 array，从而修改 slice</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := []int&#123;1, 2, 3&#125;</span><br><span class=\"line\">    func(arr []int) &#123;</span><br><span class=\"line\">        arr[0] = 7</span><br><span class=\"line\">        fmt.Println(x)    // [7 2 3]</span><br><span class=\"line\">    &#125;(x)</span><br><span class=\"line\">    fmt.Println(x)    // [7 2 3]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"13-range-遍历-slice-和-array-时混淆了返回值\">13.range 遍历 slice 和 array 时混淆了返回值<a href=\"post/GO语言新手可能会踩的50个坑（二）#13-range-遍历-slice-和-array-时混淆了返回值\"></a></h4><p>与其他编程语言中的 for-in 、foreach 遍历语句不同，Go 中的 range 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 错误示例</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class=\"line\">    for v := range x &#123;</span><br><span class=\"line\">        fmt.Println(v)    // 0 1 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 正确示例</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class=\"line\">    for _, v := range x &#123;    // 使用 _ 丢弃索引</span><br><span class=\"line\">        fmt.Println(v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"14-slice-和-array-其实是一维数据\">14.slice 和 array 其实是一维数据<a href=\"post/GO语言新手可能会踩的50个坑（二）#14-slice-和-array-其实是一维数据\"></a></h4><p>看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。<br>对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。<br>可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := 2</span><br><span class=\"line\">    y := 4</span><br><span class=\"line\">    </span><br><span class=\"line\">    table := make([][]int, x)</span><br><span class=\"line\">    for i  := range table &#123;</span><br><span class=\"line\">        table[i] = make([]int, y)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    h, w := 2, 4</span><br><span class=\"line\">    raw := make([]int, h*w)</span><br><span class=\"line\"></span><br><span class=\"line\">    for i := range raw &#123;</span><br><span class=\"line\">        raw[i] = i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 初始化原始 slice</span><br><span class=\"line\">    fmt.Println(raw, &amp;raw[4])    // [0 1 2 3 4 5 6 7] 0xc420012120 </span><br><span class=\"line\">    </span><br><span class=\"line\">    table := make([][]int, h)</span><br><span class=\"line\">    for i := range table &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 等间距切割原始 slice，创建动态多维数组 table</span><br><span class=\"line\">        // 0: raw[0*4: 0*4 + 4]</span><br><span class=\"line\">        // 1: raw[1*4: 1*4 + 4]</span><br><span class=\"line\">        table[i] = raw[i*w : i*w + w]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Println(table, &amp;table[1][0])    // [[0 1 2 3] [4 5 6 7]] 0xc420012120</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"15-访问-map-中不存在的-key\">15.访问 map 中不存在的 key<a href=\"post/GO语言新手可能会踩的50个坑（二）#15-访问-map-中不存在的-key\"></a></h4><p>Go 则会返回元素对应数据类型的零值，比如 nil、’’ 、false 和 0，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。<br>检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 错误的 key 检测方式</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := map[string]string&#123;&quot;one&quot;: &quot;2&quot;, &quot;two&quot;: &quot;&quot;, &quot;three&quot;: &quot;3&quot;&#125;</span><br><span class=\"line\">    if v := x[&quot;two&quot;]; v == &quot;&quot; &#123;</span><br><span class=\"line\">        fmt.Println(&quot;key two is no entry&quot;)    // 键 two 存不存在都会返回的空字符串</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 正确示例</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := map[string]string&#123;&quot;one&quot;: &quot;2&quot;, &quot;two&quot;: &quot;&quot;, &quot;three&quot;: &quot;3&quot;&#125;</span><br><span class=\"line\">    if _, ok := x[&quot;two&quot;]; !ok &#123;</span><br><span class=\"line\">        fmt.Println(&quot;key two is no entry&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"16-string-类型的值是常量，不可更改\">16.string 类型的值是常量，不可更改<a href=\"post/GO语言新手可能会踩的50个坑（二）#16-string-类型的值是常量，不可更改\"></a></h4><p>尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。<br>string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修改字符串的错误示例</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := &quot;text&quot;</span><br><span class=\"line\">    x[0] = &quot;T&quot;        // error: cannot assign to x[0]</span><br><span class=\"line\">    fmt.Println(x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 修改示例</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := &quot;text&quot;</span><br><span class=\"line\">    xBytes := []byte(x)</span><br><span class=\"line\">    xBytes[0] = &apos;T&apos;    // 注意此时的 T 是 rune 类型</span><br><span class=\"line\">    x = string(xBytes)</span><br><span class=\"line\">    fmt.Println(x)    // Text</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意： 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。<br>更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := &quot;text&quot;</span><br><span class=\"line\">    xRunes := []rune(x)</span><br><span class=\"line\">    xRunes[0] = &apos;我&apos;</span><br><span class=\"line\">    x = string(xRunes)</span><br><span class=\"line\">    fmt.Println(x)    // 我ext</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"17-string-与-byte-slice-之间的转换\">17.string 与 byte slice 之间的转换<a href=\"post/GO语言新手可能会踩的50个坑（二）#17-string-与-byte-slice-之间的转换\"></a></h4><p>当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。<br>Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配：<br>1.map[string] 中查找 key 时，使用了对应的 []byte，避免做 m[string(key)] 的内存分配<br>2.使用 for range 迭代 string 转换为 []byte 的迭代：for i,v := range []byte(str) {…}</p>\n<h4 id=\"18-string-与索引操作符\">18.string 与索引操作符<a href=\"post/GO语言新手可能会踩的50个坑（二）#18-string-与索引操作符\"></a></h4><p>对字符串用索引访问返回的不是字符，而是一个 byte 值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x := &quot;ascii&quot;</span><br><span class=\"line\">    fmt.Println(x[0])        // 97</span><br><span class=\"line\">    fmt.Printf(&quot;%T\\n&quot;, x[0])// uint8</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果需要使用 for range 迭代访问字符串中的字符（unicode code point / rune），标准库中有 “unicode/utf8” 包来做 UTF8 的相关解码编码。另外 utf8string 也有像 func (s *String) At(i int) rune 等很方便的库函数。</p>\n<h4 id=\"19-字符串并不都是-UTF8-文本\">19.字符串并不都是 UTF8 文本<a href=\"post/GO语言新手可能会踩的50个坑（二）#19-字符串并不都是-UTF8-文本\"></a></h4><p>string 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。<br>判断字符串是否是 UTF8 文本，可使用 “unicode/utf8” 包中的 ValidString() 函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    str1 := &quot;ABC&quot;</span><br><span class=\"line\">    fmt.Println(utf8.ValidString(str1))    // true</span><br><span class=\"line\"></span><br><span class=\"line\">    str2 := &quot;A\\xfeC&quot;</span><br><span class=\"line\">    fmt.Println(utf8.ValidString(str2))    // false</span><br><span class=\"line\"></span><br><span class=\"line\">    str3 := &quot;A\\\\xfeC&quot;</span><br><span class=\"line\">    fmt.Println(utf8.ValidString(str3))    // true    // 把转义字符转义成字面值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"20-字符串的长度\">20.字符串的长度<a href=\"post/GO语言新手可能会踩的50个坑（二）#20-字符串的长度\"></a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    char := &quot;♥&quot;</span><br><span class=\"line\">    fmt.Println(len(char))    // 3</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Go 的内建函数 len() 返回的是字符串的 byte 数量，而不是像 Python 中那样是计算 Unicode 字符数。<br>如果要得到字符串的字符数，可使用 “unicode/utf8” 包中的 RuneCountInString(str string) (n int)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    char := &quot;♥&quot;</span><br><span class=\"line\">    fmt.Println(utf8.RuneCountInString(char))    // 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","prev":{"title":"GO语言新手可能会踩的50个坑（三）","slug":"GO语言新手可能会踩的50个坑（三）"},"next":{"title":"理解golang的init函数","slug":"理解golang的init函数"},"link":"http://yoursite.com/post/GO语言新手可能会踩的50个坑（二）/"}