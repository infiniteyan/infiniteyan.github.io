{"title":"GO语言新手可能会踩的50个坑（四）","date":"2019-05-11T09:20:02.000Z","slug":"GO语言新手可能会踩的50个坑（四）","comments":true,"updated":"2019-05-11T10:14:14.094Z","content":"<h4 id=\"31-程序退出时还有-goroutine-在执行\">31.程序退出时还有 goroutine 在执行<a href=\"post/GO语言新手可能会踩的50个坑（四）#31-程序退出时还有-goroutine-在执行\"></a></h4><p>程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 主程序会直接退出</span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    workerCount := 2</span><br><span class=\"line\">    for i := 0; i &lt; workerCount; i++ &#123;</span><br><span class=\"line\">        go doIt(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    time.Sleep(1 * time.Second)</span><br><span class=\"line\">    fmt.Println(&quot;all done!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func doIt(workerID int) &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;[%v] is running\\n&quot;, workerID)</span><br><span class=\"line\">    time.Sleep(3 * time.Second)        // 模拟 goroutine 正在执行 </span><br><span class=\"line\">    fmt.Printf(&quot;[%v] is done\\n&quot;, workerID)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如下，main() 主程序不等两个 goroutine 执行完就直接退出了。<br>常用解决办法：使用 “WaitGroup” 变量，它会让主程序等待所有 goroutine 执行完毕再退出。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;fmt&quot;</span><br><span class=\"line\">\t&quot;sync&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tvar wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\">\tworkerCount := 2</span><br><span class=\"line\">\twg.Add(2)</span><br><span class=\"line\">\tfor i := 0; i &lt; workerCount; i++ &#123;</span><br><span class=\"line\">\t\tgo doIt(i, &amp;wg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">\tfmt.Println(&quot;all done!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func doIt(workerID int, wg *sync.WaitGroup) &#123;</span><br><span class=\"line\">\tfmt.Printf(&quot;[%v] is running\\n&quot;, workerID)</span><br><span class=\"line\">\tdefer wg.Done()</span><br><span class=\"line\">\tfmt.Printf(&quot;[%v] is done\\n&quot;, workerID)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"32-独占CPU导致其它Goroutine饿死\">32.独占CPU导致其它Goroutine饿死<a href=\"post/GO语言新手可能会踩的50个坑（四）#32-独占CPU导致其它Goroutine饿死\"></a></h4><p>Goroutine是协作式调度, Goroutine本身不会主动放弃CPU。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    runtime.GOMAXPROCS(1)</span><br><span class=\"line\"></span><br><span class=\"line\">    go func() &#123;</span><br><span class=\"line\">        for i := 0; i &lt; 10; i++ &#123;</span><br><span class=\"line\">            fmt.Println(i)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    for &#123;&#125; // 占用CPU</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解决的方法是在for循环加入runtime.Gosched()调度函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    runtime.GOMAXPROCS(1)</span><br><span class=\"line\"></span><br><span class=\"line\">    go func() &#123;</span><br><span class=\"line\">        for i := 0; i &lt; 10; i++ &#123;</span><br><span class=\"line\">            fmt.Println(i)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    for &#123;</span><br><span class=\"line\">        runtime.Gosched()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者是通过阻塞的方式避免CPU占用:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    runtime.GOMAXPROCS(1)</span><br><span class=\"line\"></span><br><span class=\"line\">    go func() &#123;</span><br><span class=\"line\">        for i := 0; i &lt; 10; i++ &#123;</span><br><span class=\"line\">            fmt.Println(i)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    select&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"33-向已关闭的-channel-发送数据会造成-panic\">33.向已关闭的 channel 发送数据会造成 panic<a href=\"post/GO语言新手可能会踩的50个坑（四）#33-向已关闭的-channel-发送数据会造成-panic\"></a></h4><p>从已关闭的 channel 接收数据是安全的：<br>接收状态值 ok 是 false 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 false<br>向已关闭的 channel 中发送数据会造成 panic：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    ch := make(chan int)</span><br><span class=\"line\">    for i := 0; i &lt; 3; i++ &#123;</span><br><span class=\"line\">        go func(idx int) &#123;</span><br><span class=\"line\">            ch &lt;- idx</span><br><span class=\"line\">        &#125;(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Println(&lt;-ch)        // 输出第一个发送的值</span><br><span class=\"line\">    close(ch)            // 不能关闭，还有其他的 sender</span><br><span class=\"line\">    time.Sleep(2 * time.Second)    // 模拟做其他的操作</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>针对上边有 bug 的这个例子，可使用一个废弃 channel done 来告诉剩余的 goroutine 无需再向 ch 发送数据。此时 &lt;- done 的结果是 {}：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    ch := make(chan int)</span><br><span class=\"line\">    done := make(chan struct&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    for i := 0; i &lt; 3; i++ &#123;</span><br><span class=\"line\">        go func(idx int) &#123;</span><br><span class=\"line\">            select &#123;</span><br><span class=\"line\">            case ch &lt;- (idx + 1) * 2:</span><br><span class=\"line\">                fmt.Println(idx, &quot;Send result&quot;)</span><br><span class=\"line\">            case &lt;-done:</span><br><span class=\"line\">                fmt.Println(idx, &quot;Exiting&quot;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Println(&quot;Result: &quot;, &lt;-ch)</span><br><span class=\"line\">    close(done)</span><br><span class=\"line\">    time.Sleep(3 * time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"34-使用了值为-nil-的-channel\">34.使用了值为 nil 的 channel<a href=\"post/GO语言新手可能会踩的50个坑（四）#34-使用了值为-nil-的-channel\"></a></h4><p>在一个值为 nil 的 channel 上发送和接收数据将永久阻塞：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    var ch chan int // 未初始化，值为 nil</span><br><span class=\"line\">    for i := 0; i &lt; 3; i++ &#123;</span><br><span class=\"line\">        go func(i int) &#123;</span><br><span class=\"line\">            ch &lt;- i</span><br><span class=\"line\">        &#125;(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Println(&quot;Result: &quot;, &lt;-ch)</span><br><span class=\"line\">    time.Sleep(2 * time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"35-若函数-receiver-传参是传值方式，则无法修改参数的原有值\">35.若函数 receiver 传参是传值方式，则无法修改参数的原有值<a href=\"post/GO语言新手可能会踩的50个坑（四）#35-若函数-receiver-传参是传值方式，则无法修改参数的原有值\"></a></h4><p>方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。<br>除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type data struct &#123;</span><br><span class=\"line\">    num   int</span><br><span class=\"line\">    key   *string</span><br><span class=\"line\">    items map[string]bool</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (this *data) pointerFunc() &#123;</span><br><span class=\"line\">    this.num = 7</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (this data) valueFunc() &#123;</span><br><span class=\"line\">    this.num = 8</span><br><span class=\"line\">    *this.key = &quot;valueFunc.key&quot;</span><br><span class=\"line\">    this.items[&quot;valueFunc&quot;] = true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    key := &quot;key1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    d := data&#123;1, &amp;key, make(map[string]bool)&#125;</span><br><span class=\"line\">    fmt.Printf(&quot;num=%v  key=%v  items=%v\\n&quot;, d.num, *d.key, d.items)</span><br><span class=\"line\"></span><br><span class=\"line\">    d.pointerFunc()    // 修改 num 的值为 7</span><br><span class=\"line\">    fmt.Printf(&quot;num=%v  key=%v  items=%v\\n&quot;, d.num, *d.key, d.items)</span><br><span class=\"line\"></span><br><span class=\"line\">    d.valueFunc()    // 修改 key 和 items 的值</span><br><span class=\"line\">    fmt.Printf(&quot;num=%v  key=%v  items=%v\\n&quot;, d.num, *d.key, d.items)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","prev":{"title":"Iris框架MVC例子","slug":"Iris框架MVC例子"},"next":{"title":"GO语言新手可能会踩的50个坑（三）","slug":"GO语言新手可能会踩的50个坑（三）"},"link":"http://yoursite.com/post/GO语言新手可能会踩的50个坑（四）/"}