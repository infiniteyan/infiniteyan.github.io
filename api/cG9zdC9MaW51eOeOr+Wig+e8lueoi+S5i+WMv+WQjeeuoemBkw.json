{"title":"Linux环境编程之匿名管道","date":"2019-06-25T14:30:53.000Z","slug":"Linux环境编程之匿名管道","comments":true,"updated":"2019-06-25T14:37:09.775Z","content":"<h4 id=\"一、什么是管道\">一、什么是管道<a href=\"post/Linux环境编程之匿名管道#一、什么是管道\"></a></h4><p>管道是Linux支持的最初Unix IPC形式之一，具有以下特点：<br>  1.管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；<br>  2.只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；<br>  3.单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。<br>  4.数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p>\n<p>管道的实现机制：<br>管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p>\n<h4 id=\"二、管道的创建（pipe）\">二、管道的创建（pipe）<a href=\"post/Linux环境编程之匿名管道#二、管道的创建（pipe）\"></a></h4><p>包含头文件&lt;unistd.h&gt;<br>功能:创建一无名管道<br>原型：<br>int pipe(int fd[2]);<br>参数：<br>fd：文件描述符数组,其中fd[0]表示读端, fd[1]表示写端<br>返回值:成功返回0，失败返回错误代码</p>\n<p>man帮助说明：<br>DESCRIPTION<br>       pipe() creates a pipe, a unidirectional data channel that can be used<br>       for interprocess communication.  The array pipefd is used to return<br>       two file descriptors referring to the ends of the pipe.  pipefd[0]<br>       refers to the read end of the pipe.  pipefd[1] refers to the write<br>       end of the pipe.  Data written to the write end of the pipe is<br>       buffered by the kernel until it is read from the read end of the<br>       pipe.  For further details, see pipe(7).</p>\n<p>该函数创建的管道的两端处于一个进程中间，在实际应 用中没有太大意义，因此，一个进程在由pipe()创建管道后，一般再fork一个子进程，然后通过管道实现父子进程间的通信（因此也不难推出，只要两个 进程中存在亲缘关系，这里的亲缘关系指的是具有共同的祖先，都可以采用管道方式来进行通信）。父子进程间具有相同的文件描述符，且指向同一个管道pipe，其他没有关系的进程不能获得pipe（）产生的两个文件描述符，也就不能利用同一个管道进行通信。<br>创建管道后示意图：<br><img src=\"/2019/06/25/Linux环境编程之匿名管道/001.png\" alt=\"aa\"></p>\n<h4 id=\"三、利用管道进行父子进程间数据传输\">三、利用管道进行父子进程间数据传输<a href=\"post/Linux环境编程之匿名管道#三、利用管道进行父子进程间数据传输\"></a></h4><p>示例一：子进程向管道中写数据，父进程从管道中读出数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int fds[2];</span><br><span class=\"line\">    if(pipe(fds) == -1)&#123;</span><br><span class=\"line\">        perror(&quot;pipe error&quot;);</span><br><span class=\"line\">        exit(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pid_t pid;</span><br><span class=\"line\">    pid = fork();</span><br><span class=\"line\">    if(pid == -1)&#123;</span><br><span class=\"line\">        perror(&quot;fork error&quot;);</span><br><span class=\"line\">        exit(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(pid == 0)&#123;</span><br><span class=\"line\">        close(fds[0]);//子进程关闭读端</span><br><span class=\"line\">        write(fds[1],&quot;hello&quot;,5);</span><br><span class=\"line\">        exit(EXIT_SUCCESS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    close(fds[1]);//父进程关闭写端</span><br><span class=\"line\">    char buf[10] = &#123;0&#125;;</span><br><span class=\"line\">    read(fds[0],buf,10);</span><br><span class=\"line\">    printf(&quot;receive datas = %s\\n&quot;,buf);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>示例二：利用管道实现ls |wc –w功能<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;fcntl.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void) &#123;</span><br><span class=\"line\">    int fds[2];</span><br><span class=\"line\">    if(pipe(fds) == -1) &#123;</span><br><span class=\"line\">        perror(&quot;pipe error&quot;);</span><br><span class=\"line\">        exit(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pid_t pid;</span><br><span class=\"line\">    pid = fork();</span><br><span class=\"line\">    if (pid == -1) &#123;</span><br><span class=\"line\">        perror(&quot;fork error&quot;);</span><br><span class=\"line\">        exit(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (pid == 0) &#123;</span><br><span class=\"line\">        dup2(fds[1], STDOUT_FILENO);//复制文件描述符且指定新复制的fd为标准输出</span><br><span class=\"line\">        close(fds[0]);//子进程关闭读端</span><br><span class=\"line\">        close(fds[1]);</span><br><span class=\"line\">        execlp(&quot;ls&quot;, &quot;ls&quot;, NULL);</span><br><span class=\"line\">        fprintf(stderr, &quot;exec error\\n&quot;);</span><br><span class=\"line\">        exit(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dup2(fds[0], STDIN_FILENO);</span><br><span class=\"line\">    close(fds[1]);//父进程关闭写端</span><br><span class=\"line\">    close(fds[0]);</span><br><span class=\"line\">    execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-w&quot;, NULL);</span><br><span class=\"line\">    fprintf(stderr, &quot;error execute wc\\n&quot;);</span><br><span class=\"line\">    exit(EXIT_FAILURE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","next":{"title":"GO实现BST二叉搜索树","slug":"GO实现BST二叉搜索树"},"link":"http://yoursite.com/post/Linux环境编程之匿名管道/"}